"""
Get the "scheme" corresponding to the input parameters.

:param dist_name: the name of the package to retrieve the scheme for, used
    in the headers scheme path
:param user: indicates to use the "user" scheme
:param home: indicates to use the "home" scheme
:param root: root under which other directories are re-based
:param isolated: ignored, but kept for distutils compatibility (where
    this controls whether the user-site pydistutils.cfg is honored)
:param prefix: indicates to use the "prefix" scheme and provides the
    base directory for the same
"""
if user and prefix:
    raise InvalidSchemeCombination("--user", "--prefix")
if home and prefix:
    raise InvalidSchemeCombination("--home", "--prefix")

if home is not None:
    scheme_name = _infer_home()
elif user:
    scheme_name = _infer_user()
else:
    scheme_name = _infer_prefix()

# Special case: When installing into a custom prefix, use posix_prefix
# instead of osx_framework_library. See _should_use_osx_framework_prefix()
# docstring for details.
if prefix is not None and scheme_name == "osx_framework_library":
    scheme_name = "posix_prefix"

if home is not None:
    variables = {k: home for k in _HOME_KEYS}
elif prefix is not None:
    variables = {k: prefix for k in _HOME_KEYS}
else:
    variables = {}

paths = sysconfig.get_paths(scheme=scheme_name, vars=variables)

# Logic here is very arbitrary, we're doing it for compatibility, don't ask.
# 1. Pip historically uses a special header path in virtual environments.
# 2. If the distribution name is not known, distutils uses 'UNKNOWN'. We
#    only do the same when not running in a virtual environment because
#    pip's historical header path logic (see point 1) did not do this.
if running_under_virtualenv():
    if user:
        base = variables.get("userbase", sys.prefix)
    else:
        base = variables.get("base", sys.prefix)
    python_xy = f"python{get_major_minor_version()}"
    paths["include"] = os.path.join(base, "include", "site", python_xy)
elif not dist_name:
    dist_name = "UNKNOWN"

scheme = Scheme(
    platlib=paths["platlib"],
    purelib=paths["purelib"],
    headers=os.path.join(paths["include"], dist_name),
    scripts=paths["scripts"],
    data=paths["data"],
)
if root is not None:
    for key in SCHEME_KEYS:
        value = change_root(root, getattr(scheme, key))
        setattr(scheme, key, value)
return scheme


