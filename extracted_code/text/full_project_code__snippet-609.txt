"""Helper to quickly define a set of alternative :class:`Literal` s,
and makes sure to do longest-first testing when there is a conflict,
regardless of the input order, but returns
a :class:`MatchFirst` for best performance.

Parameters:

- ``strs`` - a string of space-delimited literals, or a collection of
  string literals
- ``caseless`` - treat all literals as caseless - (default= ``False``)
- ``use_regex`` - as an optimization, will
  generate a :class:`Regex` object; otherwise, will generate
  a :class:`MatchFirst` object (if ``caseless=True`` or ``as_keyword=True``, or if
  creating a :class:`Regex` raises an exception) - (default= ``True``)
- ``as_keyword`` - enforce :class:`Keyword`-style matching on the
  generated expressions - (default= ``False``)
- ``asKeyword`` and ``useRegex`` are retained for pre-PEP8 compatibility,
  but will be removed in a future release

Example::

    comp_oper = one_of("< = > <= >= !=")
    var = Word(alphas)
    number = Word(nums)
    term = var | number
    comparison_expr = term + comp_oper + term
    print(comparison_expr.search_string("B = 12  AA=23 B<=AA AA>12"))

prints::

    [['B', '=', '12'], ['AA', '=', '23'], ['B', '<=', 'AA'], ['AA', '>', '12']]
"""
asKeyword = asKeyword or as_keyword
useRegex = useRegex and use_regex

if (
    isinstance(caseless, str_type)
    and __diag__.warn_on_multiple_string_args_to_oneof
):
    warnings.warn(
        "More than one string argument passed to one_of, pass"
        " choices as a list or space-delimited string",
        stacklevel=2,
    )

if caseless:
    isequal = lambda a, b: a.upper() == b.upper()
    masks = lambda a, b: b.upper().startswith(a.upper())
    parseElementClass = CaselessKeyword if asKeyword else CaselessLiteral
else:
    isequal = lambda a, b: a == b
    masks = lambda a, b: b.startswith(a)
    parseElementClass = Keyword if asKeyword else Literal

symbols: List[str] = []
if isinstance(strs, str_type):
    strs = typing.cast(str, strs)
    symbols = strs.split()
elif isinstance(strs, Iterable):
    symbols = list(strs)
else:
    raise TypeError("Invalid argument to one_of, expected string or iterable")
if not symbols:
    return NoMatch()

# reorder given symbols to take care to avoid masking longer choices with shorter ones
# (but only if the given symbols are not just single characters)
if any(len(sym) > 1 for sym in symbols):
    i = 0
    while i < len(symbols) - 1:
        cur = symbols[i]
        for j, other in enumerate(symbols[i + 1 :]):
            if isequal(other, cur):
                del symbols[i + j + 1]
                break
            elif masks(cur, other):
                del symbols[i + j + 1]
                symbols.insert(i, other)
                break
        else:
            i += 1

if useRegex:
    re_flags: int = re.IGNORECASE if caseless else 0

    try:
        if all(len(sym) == 1 for sym in symbols):
            # symbols are just single characters, create range regex pattern
            patt = f"[{''.join(_escape_regex_range_chars(sym) for sym in symbols)}]"
        else:
            patt = "|".join(re.escape(sym) for sym in symbols)

        # wrap with \b word break markers if defining as keywords
        if asKeyword:
            patt = rf"\b(?:{patt})\b"

        ret = Regex(patt, flags=re_flags).set_name(" | ".join(symbols))

        if caseless:
            # add parse action to return symbols as specified, not in random
            # casing as found in input string
            symbol_map = {sym.lower(): sym for sym in symbols}
            ret.add_parse_action(lambda s, l, t: symbol_map[t[0].lower()])

        return ret

    except re.error:
        warnings.warn(
            "Exception creating Regex for one_of, building MatchFirst", stacklevel=2
        )

# last resort, just use MatchFirst
return MatchFirst(parseElementClass(sym) for sym in symbols).set_name(
    " | ".join(symbols)
)


