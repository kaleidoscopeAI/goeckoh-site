parser = create_main_parser()

# Note: parser calls disable_interspersed_args(), so the result of this
# call is to split the initial args into the general options before the
# subcommand and everything else.
# For example:
#  args: ['--timeout=5', 'install', '--user', 'INITools']
#  general_options: ['--timeout==5']
#  args_else: ['install', '--user', 'INITools']
general_options, args_else = parser.parse_args(args)

# --python
if general_options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:
    # Re-invoke pip using the specified Python interpreter
    interpreter = identify_python_interpreter(general_options.python)
    if interpreter is None:
        raise CommandError(
            f"Could not locate Python interpreter {general_options.python}"
        )

    pip_cmd = [
        interpreter,
        get_runnable_pip(),
    ]
    pip_cmd.extend(args)

    # Set a flag so the child doesn't re-invoke itself, causing
    # an infinite loop.
    os.environ["_PIP_RUNNING_IN_SUBPROCESS"] = "1"
    returncode = 0
    try:
        proc = subprocess.run(pip_cmd)
        returncode = proc.returncode
    except (subprocess.SubprocessError, OSError) as exc:
        raise CommandError(f"Failed to run pip under {interpreter}: {exc}")
    sys.exit(returncode)

# --version
if general_options.version:
    sys.stdout.write(parser.version)
    sys.stdout.write(os.linesep)
    sys.exit()

# pip || pip help -> print_help()
if not args_else or (args_else[0] == "help" and len(args_else) == 1):
    parser.print_help()
    sys.exit()

# the subcommand name
cmd_name = args_else[0]

if cmd_name not in commands_dict:
    guess = get_similar_commands(cmd_name)

    msg = [f'unknown command "{cmd_name}"']
    if guess:
        msg.append(f'maybe you meant "{guess}"')

    raise CommandError(" - ".join(msg))

# all the args without the subcommand
cmd_args = args[:]
cmd_args.remove(cmd_name)

return cmd_name, cmd_args


