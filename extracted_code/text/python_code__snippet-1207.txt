"""
Filter out candidates whose hashes aren't allowed, and return a new
list of candidates.

If at least one candidate has an allowed hash, then all candidates with
either an allowed hash or no hash specified are returned.  Otherwise,
the given candidates are returned.

Including the candidates with no hash specified when there is a match
allows a warning to be logged if there is a more preferred candidate
with no hash specified.  Returning all candidates in the case of no
matches lets pip report the hash of the candidate that would otherwise
have been installed (e.g. permitting the user to more easily update
their requirements file with the desired hash).
"""
if not hashes:
    logger.debug(
        "Given no hashes to check %s links for project %r: "
        "discarding no candidates",
        len(candidates),
        project_name,
    )
    # Make sure we're not returning back the given value.
    return list(candidates)

matches_or_no_digest = []
# Collect the non-matches for logging purposes.
non_matches = []
match_count = 0
for candidate in candidates:
    link = candidate.link
    if not link.has_hash:
        pass
    elif link.is_hash_allowed(hashes=hashes):
        match_count += 1
    else:
        non_matches.append(candidate)
        continue

    matches_or_no_digest.append(candidate)

if match_count:
    filtered = matches_or_no_digest
else:
    # Make sure we're not returning back the given value.
    filtered = list(candidates)

if len(filtered) == len(candidates):
    discard_message = "discarding no candidates"
else:
    discard_message = "discarding {} non-matches:\n  {}".format(
        len(non_matches),
        "\n  ".join(str(candidate.link) for candidate in non_matches),
    )

logger.debug(
    "Checked %s links for project %r against %s hashes "
    "(%s matches, %s no digest): %s",
    len(candidates),
    project_name,
    hashes.digest_count,
    match_count,
    len(matches_or_no_digest) - match_count,
    discard_message,
)

return filtered


