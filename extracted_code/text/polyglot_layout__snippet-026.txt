        $part_ent = 0.0;

        for ($i = 0; $i < $parts; $i++) {

            $subset = [];

            for ($j = $i; $j < $n; $j += $parts) $subset[] = $vec[$j];

            $part_ent += $this->entropy($subset);

        }

        $part_ent /= $parts;

        return max(0.0, $sys_ent - $part_ent);

    }

}

class KnowledgeDNA {

    public int $generation = 0;

    public function replicate(): void { $this->generation++; }

}

class MemoryStore {

    private ?\SQLite3 $db = null;

    public function __construct(string $path) {

        try {

            $this->db = new \SQLite3($path);

            if (!$this->db) throw new Exception('Failed to open SQLite database.');

            $this->db->exec('CREATE TABLE IF NOT EXISTS dna (gen INTEGER PRIMARY KEY, phi REAL);');

        } catch (Exception $e) {

            error_log('Database initialization failed: ' . $e->getMessage());

            $this->db = null;

        }

    }

    public function save_state(int $gen, float $phi): void {

        if (!$this->db) return;

        $stmt = $this->db->prepare('INSERT OR REPLACE INTO dna (gen, phi) VALUES (:gen, :phi);');

        if (!$stmt) {

            error_log('SQLite prepare failed: ' . $this->db->lastErrorMsg());

            return;

        }

        $stmt->bindValue(':gen', $gen, SQLITE3_INTEGER);

        $stmt->bindValue(':phi', $phi, SQLITE3_FLOAT);

        $result = $stmt->execute();

        if (!$result) {

            error_log('SQLite execute failed: ' . $this->db->lastErrorMsg());

