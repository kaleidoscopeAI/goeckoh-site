global nodes, node_id_counter

current_target = dynamic_targets[frame // (num_generations // len(dynamic_targets))]
next_gen_nodes = []

for node in nodes:
    node.evaluate_fitness(current_target)
    if np.random.rand() < 0.5:
        child_node = node.replicate(mutation_rate, node_id_counter)
        node_id_counter += 1
        next_gen_nodes.append(child_node)

nodes = sorted([n for n in nodes if n.fitness is not None], key=lambda n: n.fitness, reverse=True)[:len(nodes) // 2]
nodes.extend(next_gen_nodes)

avg_fitness = np.mean([node.fitness for node in nodes if node.fitness is not None])
fitness_trends.append(avg_fitness)
replication_counts.append(len(next_gen_nodes))

positions = np.array([node.position for node in nodes])
if positions.size > 0:
    scatters.set_offsets(positions)
    sizes = [(1 + (node.fitness or 0)) * 100 for node in nodes]
    colors = [node.dna[:3] for node in nodes]
    scatters.set_sizes(sizes)
    scatters.set_facecolor(colors)

fitness_line.set_data(range(len(fitness_trends)), fitness_trends)
replication_line.set_data(range(len(replication_counts)), replication_counts)
trend_ax.set_xlim(0, len(fitness_trends))
trend_ax.set_ylim(0, max(max(fitness_trends, default=0), max(replication_counts, default=0)) + 1)

return scatters, fitness_line, replication_line

