"""
Behaves just like :class:`PoolManager`, but sends all requests through
the defined proxy, using the CONNECT method for HTTPS URLs.

:param proxy_url:
    The URL of the proxy to be used.

:param proxy_headers:
    A dictionary containing headers that will be sent to the proxy. In case
    of HTTP they are being sent with each request, while in the
    HTTPS/CONNECT case they are sent only once. Could be used for proxy
    authentication.

:param proxy_ssl_context:
    The proxy SSL context is used to establish the TLS connection to the
    proxy when using HTTPS proxies.

:param use_forwarding_for_https:
    (Defaults to False) If set to True will forward requests to the HTTPS
    proxy to be made on behalf of the client instead of creating a TLS
    tunnel via the CONNECT method. **Enabling this flag means that request
    and response headers and content will be visible from the HTTPS proxy**
    whereas tunneling keeps request and response headers and content
    private.  IP address, target hostname, SNI, and port are always visible
    to an HTTPS proxy even when this flag is disabled.

Example:
    >>> proxy = urllib3.ProxyManager('http://localhost:3128/')
    >>> r1 = proxy.request('GET', 'http://google.com/')
    >>> r2 = proxy.request('GET', 'http://httpbin.org/')
    >>> len(proxy.pools)
    1
    >>> r3 = proxy.request('GET', 'https://httpbin.org/')
    >>> r4 = proxy.request('GET', 'https://twitter.com/')
    >>> len(proxy.pools)
    3

"""

def __init__(
    self,
    proxy_url,
    num_pools=10,
    headers=None,
    proxy_headers=None,
    proxy_ssl_context=None,
    use_forwarding_for_https=False,
    **connection_pool_kw
):

    if isinstance(proxy_url, HTTPConnectionPool):
        proxy_url = "%s://%s:%i" % (
            proxy_url.scheme,
            proxy_url.host,
            proxy_url.port,
        )
    proxy = parse_url(proxy_url)

    if proxy.scheme not in ("http", "https"):
        raise ProxySchemeUnknown(proxy.scheme)

    if not proxy.port:
        port = port_by_scheme.get(proxy.scheme, 80)
        proxy = proxy._replace(port=port)

    self.proxy = proxy
    self.proxy_headers = proxy_headers or {}
    self.proxy_ssl_context = proxy_ssl_context
    self.proxy_config = ProxyConfig(proxy_ssl_context, use_forwarding_for_https)

    connection_pool_kw["_proxy"] = self.proxy
    connection_pool_kw["_proxy_headers"] = self.proxy_headers
    connection_pool_kw["_proxy_config"] = self.proxy_config

    super(ProxyManager, self).__init__(num_pools, headers, **connection_pool_kw)

def connection_from_host(self, host, port=None, scheme="http", pool_kwargs=None):
    if scheme == "https":
        return super(ProxyManager, self).connection_from_host(
            host, port, scheme, pool_kwargs=pool_kwargs
        )

    return super(ProxyManager, self).connection_from_host(
        self.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs
    )

def _set_proxy_headers(self, url, headers=None):
    """
    Sets headers needed by proxies: specifically, the Accept and Host
    headers. Only sets headers not provided by the user.
    """
    headers_ = {"Accept": "*/*"}

    netloc = parse_url(url).netloc
    if netloc:
        headers_["Host"] = netloc

    if headers:
        headers_.update(headers)
    return headers_

def urlopen(self, method, url, redirect=True, **kw):
    "Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute."
    u = parse_url(url)
    if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):
        # For connections using HTTP CONNECT, httplib sets the necessary
        # headers on the CONNECT to the proxy. If we're not using CONNECT,
        # we'll definitely need to set 'Host' at the very least.
        headers = kw.get("headers", self.headers)
        kw["headers"] = self._set_proxy_headers(url, headers)

    return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)


