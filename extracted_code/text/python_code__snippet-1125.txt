installations: Dict[str, FrozenRequirement] = {}

dists = get_environment(paths).iter_installed_distributions(
    local_only=local_only,
    skip=(),
    user_only=user_only,
)
for dist in dists:
    req = FrozenRequirement.from_dist(dist)
    if exclude_editable and req.editable:
        continue
    installations[req.canonical_name] = req

if requirement:
    # the options that don't get turned into an InstallRequirement
    # should only be emitted once, even if the same option is in multiple
    # requirements files, so we need to keep track of what has been emitted
    # so that we don't emit it again if it's seen again
    emitted_options: Set[str] = set()
    # keep track of which files a requirement is in so that we can
    # give an accurate warning if a requirement appears multiple times.
    req_files: Dict[str, List[str]] = collections.defaultdict(list)
    for req_file_path in requirement:
        with open(req_file_path) as req_file:
            for line in req_file:
                if (
                    not line.strip()
                    or line.strip().startswith("#")
                    or line.startswith(
                        (
                            "-r",
                            "--requirement",
                            "-f",
                            "--find-links",
                            "-i",
                            "--index-url",
                            "--pre",
                            "--trusted-host",
                            "--process-dependency-links",
                            "--extra-index-url",
                            "--use-feature",
                        )
                    )
                ):
                    line = line.rstrip()
                    if line not in emitted_options:
                        emitted_options.add(line)
                        yield line
                    continue

                if line.startswith("-e") or line.startswith("--editable"):
                    if line.startswith("-e"):
                        line = line[2:].strip()
                    else:
                        line = line[len("--editable") :].strip().lstrip("=")
                    line_req = install_req_from_editable(
                        line,
                        isolated=isolated,
                    )
                else:
                    line_req = install_req_from_line(
                        COMMENT_RE.sub("", line).strip(),
                        isolated=isolated,
                    )

                if not line_req.name:
                    logger.info(
                        "Skipping line in requirement file [%s] because "
                        "it's not clear what it would install: %s",
                        req_file_path,
                        line.strip(),
                    )
                    logger.info(
                        "  (add #egg=PackageName to the URL to avoid"
                        " this warning)"
                    )
                else:
                    line_req_canonical_name = canonicalize_name(line_req.name)
                    if line_req_canonical_name not in installations:
                        # either it's not installed, or it is installed
                        # but has been processed already
                        if not req_files[line_req.name]:
                            logger.warning(
                                "Requirement file [%s] contains %s, but "
                                "package %r is not installed",
                                req_file_path,
                                COMMENT_RE.sub("", line).strip(),
                                line_req.name,
                            )
                        else:
                            req_files[line_req.name].append(req_file_path)
                    else:
                        yield str(installations[line_req_canonical_name]).rstrip()
                        del installations[line_req_canonical_name]
                        req_files[line_req.name].append(req_file_path)

    # Warn about requirements that were included multiple times (in a
    # single requirements file or in different requirements files).
    for name, files in req_files.items():
        if len(files) > 1:
            logger.warning(
                "Requirement %s included multiple times [%s]",
                name,
                ", ".join(sorted(set(files))),
            )

    yield ("## The following requirements were added by pip freeze:")
for installation in sorted(installations.values(), key=lambda x: x.name.lower()):
    if installation.canonical_name not in skip:
        yield str(installation).rstrip()


