"""Requires all given :class:`ParseExpression` s to be found, but in
any order. Expressions may be separated by whitespace.

May be constructed using the ``'&'`` operator.

Example::

    color = one_of("RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN")
    shape_type = one_of("SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON")
    integer = Word(nums)
    shape_attr = "shape:" + shape_type("shape")
    posn_attr = "posn:" + Group(integer("x") + ',' + integer("y"))("posn")
    color_attr = "color:" + color("color")
    size_attr = "size:" + integer("size")

    # use Each (using operator '&') to accept attributes in any order
    # (shape and posn are required, color and size are optional)
    shape_spec = shape_attr & posn_attr & Opt(color_attr) & Opt(size_attr)

    shape_spec.run_tests('''
        shape: SQUARE color: BLACK posn: 100, 120
        shape: CIRCLE size: 50 color: BLUE posn: 50,80
        color:GREEN size:20 shape:TRIANGLE posn:20,40
        '''
        )

prints::

    shape: SQUARE color: BLACK posn: 100, 120
    ['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']]
    - color: BLACK
    - posn: ['100', ',', '120']
      - x: 100
      - y: 120
    - shape: SQUARE


    shape: CIRCLE size: 50 color: BLUE posn: 50,80
    ['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']]
    - color: BLUE
    - posn: ['50', ',', '80']
      - x: 50
      - y: 80
    - shape: CIRCLE
    - size: 50


    color: GREEN size: 20 shape: TRIANGLE posn: 20,40
    ['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']]
    - color: GREEN
    - posn: ['20', ',', '40']
      - x: 20
      - y: 40
    - shape: TRIANGLE
    - size: 20
"""

def __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = True):
    super().__init__(exprs, savelist)
    if self.exprs:
        self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
    else:
        self.mayReturnEmpty = True
    self.skipWhitespace = True
    self.initExprGroups = True
    self.saveAsList = True

def __iand__(self, other):
    if isinstance(other, str_type):
        other = self._literalStringClass(other)
    if not isinstance(other, ParserElement):
        return NotImplemented
    return self.append(other)  # Each([self, other])

def streamline(self) -> ParserElement:
    super().streamline()
    if self.exprs:
        self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
    else:
        self.mayReturnEmpty = True
    return self

def parseImpl(self, instring, loc, doActions=True):
    if self.initExprGroups:
        self.opt1map = dict(
            (id(e.expr), e) for e in self.exprs if isinstance(e, Opt)
        )
        opt1 = [e.expr for e in self.exprs if isinstance(e, Opt)]
        opt2 = [
            e
            for e in self.exprs
            if e.mayReturnEmpty and not isinstance(e, (Opt, Regex, ZeroOrMore))
        ]
        self.optionals = opt1 + opt2
        self.multioptionals = [
            e.expr.set_results_name(e.resultsName, list_all_matches=True)
            for e in self.exprs
            if isinstance(e, _MultipleMatch)
        ]
        self.multirequired = [
            e.expr.set_results_name(e.resultsName, list_all_matches=True)
            for e in self.exprs
            if isinstance(e, OneOrMore)
        ]
        self.required = [
            e for e in self.exprs if not isinstance(e, (Opt, ZeroOrMore, OneOrMore))
        ]
        self.required += self.multirequired
        self.initExprGroups = False

    tmpLoc = loc
    tmpReqd = self.required[:]
    tmpOpt = self.optionals[:]
    multis = self.multioptionals[:]
    matchOrder = []

    keepMatching = True
    failed = []
    fatals = []
    while keepMatching:
        tmpExprs = tmpReqd + tmpOpt + multis
        failed.clear()
        fatals.clear()
        for e in tmpExprs:
            try:
                tmpLoc = e.try_parse(instring, tmpLoc, raise_fatal=True)
            except ParseFatalException as pfe:
                pfe.__traceback__ = None
                pfe.parser_element = e
                fatals.append(pfe)
                failed.append(e)
            except ParseException:
                failed.append(e)
            else:
                matchOrder.append(self.opt1map.get(id(e), e))
                if e in tmpReqd:
                    tmpReqd.remove(e)
                elif e in tmpOpt:
                    tmpOpt.remove(e)
        if len(failed) == len(tmpExprs):
            keepMatching = False

    # look for any ParseFatalExceptions
    if fatals:
        if len(fatals) > 1:
            fatals.sort(key=lambda e: -e.loc)
            if fatals[0].loc == fatals[1].loc:
                fatals.sort(key=lambda e: (-e.loc, -len(str(e.parser_element))))
        max_fatal = fatals[0]
        raise max_fatal

    if tmpReqd:
        missing = ", ".join([str(e) for e in tmpReqd])
        raise ParseException(
            instring,
            loc,
            f"Missing one or more required elements ({missing})",
        )

    # add any unmatched Opts, in case they have default values defined
    matchOrder += [e for e in self.exprs if isinstance(e, Opt) and e.expr in tmpOpt]

    total_results = ParseResults([])
    for e in matchOrder:
        loc, results = e._parse(instring, loc, doActions)
        total_results += results

    return loc, total_results

def _generateDefaultName(self) -> str:
    return "{" + " & ".join(str(e) for e in self.exprs) + "}"


