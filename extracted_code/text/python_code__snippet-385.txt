"""
MessagePack Packer

Usage::

    packer = Packer()
    astream.write(packer.pack(a))
    astream.write(packer.pack(b))

Packer's constructor has some keyword arguments:

:param callable default:
    Convert user type to builtin type that Packer supports.
    See also simplejson's document.

:param bool use_single_float:
    Use single precision float type for float. (default: False)

:param bool autoreset:
    Reset buffer after each pack and return its content as `bytes`. (default: True).
    If set this to false, use `bytes()` to get content and `.reset()` to clear buffer.

:param bool use_bin_type:
    Use bin type introduced in msgpack spec 2.0 for bytes.
    It also enables str8 type for unicode. (default: True)

:param bool strict_types:
    If set to true, types will be checked to be exact. Derived classes
    from serializable types will not be serialized and will be
    treated as unsupported type and forwarded to default.
    Additionally tuples will not be serialized as lists.
    This is useful when trying to implement accurate serialization
    for python types.

:param bool datetime:
    If set to true, datetime with tzinfo is packed into Timestamp type.
    Note that the tzinfo is stripped in the timestamp.
    You can get UTC datetime with `timestamp=3` option of the Unpacker.
    (Python 2 is not supported).

:param str unicode_errors:
    The error handler for encoding unicode. (default: 'strict')
    DO NOT USE THIS!!  This option is kept for very specific usage.

Example of streaming deserialize from file-like object::

    unpacker = Unpacker(file_like)
    for o in unpacker:
        process(o)

Example of streaming deserialize from socket::

    unpacker = Unpacker()
    while True:
        buf = sock.recv(1024**2)
        if not buf:
            break
        unpacker.feed(buf)
        for o in unpacker:
            process(o)

Raises ``ExtraData`` when *packed* contains extra bytes.
Raises ``OutOfData`` when *packed* is incomplete.
Raises ``FormatError`` when *packed* is not valid msgpack.
Raises ``StackError`` when *packed* contains too nested.
Other exceptions can be raised during unpacking.
"""

def __init__(
    self,
    default=None,
    use_single_float=False,
    autoreset=True,
    use_bin_type=True,
    strict_types=False,
    datetime=False,
    unicode_errors=None,
):
    self._strict_types = strict_types
    self._use_float = use_single_float
    self._autoreset = autoreset
    self._use_bin_type = use_bin_type
    self._buffer = StringIO()
    if PY2 and datetime:
        raise ValueError("datetime is not supported in Python 2")
    self._datetime = bool(datetime)
    self._unicode_errors = unicode_errors or "strict"
    if default is not None:
        if not callable(default):
            raise TypeError("default must be callable")
    self._default = default

def _pack(
    self,
    obj,
    nest_limit=DEFAULT_RECURSE_LIMIT,
    check=isinstance,
    check_type_strict=_check_type_strict,
):
    default_used = False
    if self._strict_types:
        check = check_type_strict
        list_types = list
    else:
        list_types = (list, tuple)
    while True:
        if nest_limit < 0:
            raise ValueError("recursion limit exceeded")
        if obj is None:
            return self._buffer.write(b"\xc0")
        if check(obj, bool):
            if obj:
                return self._buffer.write(b"\xc3")
            return self._buffer.write(b"\xc2")
        if check(obj, int_types):
            if 0 <= obj < 0x80:
                return self._buffer.write(struct.pack("B", obj))
            if -0x20 <= obj < 0:
                return self._buffer.write(struct.pack("b", obj))
            if 0x80 <= obj <= 0xFF:
                return self._buffer.write(struct.pack("BB", 0xCC, obj))
            if -0x80 <= obj < 0:
                return self._buffer.write(struct.pack(">Bb", 0xD0, obj))
            if 0xFF < obj <= 0xFFFF:
                return self._buffer.write(struct.pack(">BH", 0xCD, obj))
            if -0x8000 <= obj < -0x80:
                return self._buffer.write(struct.pack(">Bh", 0xD1, obj))
            if 0xFFFF < obj <= 0xFFFFFFFF:
                return self._buffer.write(struct.pack(">BI", 0xCE, obj))
            if -0x80000000 <= obj < -0x8000:
                return self._buffer.write(struct.pack(">Bi", 0xD2, obj))
            if 0xFFFFFFFF < obj <= 0xFFFFFFFFFFFFFFFF:
                return self._buffer.write(struct.pack(">BQ", 0xCF, obj))
            if -0x8000000000000000 <= obj < -0x80000000:
                return self._buffer.write(struct.pack(">Bq", 0xD3, obj))
            if not default_used and self._default is not None:
                obj = self._default(obj)
                default_used = True
                continue
            raise OverflowError("Integer value out of range")
        if check(obj, (bytes, bytearray)):
            n = len(obj)
            if n >= 2**32:
                raise ValueError("%s is too large" % type(obj).__name__)
            self._pack_bin_header(n)
            return self._buffer.write(obj)
        if check(obj, unicode):
            obj = obj.encode("utf-8", self._unicode_errors)
            n = len(obj)
            if n >= 2**32:
                raise ValueError("String is too large")
            self._pack_raw_header(n)
            return self._buffer.write(obj)
        if check(obj, memoryview):
            n = obj.nbytes
            if n >= 2**32:
                raise ValueError("Memoryview is too large")
            self._pack_bin_header(n)
            return self._buffer.write(obj)
        if check(obj, float):
            if self._use_float:
                return self._buffer.write(struct.pack(">Bf", 0xCA, obj))
            return self._buffer.write(struct.pack(">Bd", 0xCB, obj))
        if check(obj, (ExtType, Timestamp)):
            if check(obj, Timestamp):
                code = -1
                data = obj.to_bytes()
            else:
                code = obj.code
                data = obj.data
            assert isinstance(code, int)
            assert isinstance(data, bytes)
            L = len(data)
            if L == 1:
                self._buffer.write(b"\xd4")
            elif L == 2:
                self._buffer.write(b"\xd5")
            elif L == 4:
                self._buffer.write(b"\xd6")
            elif L == 8:
                self._buffer.write(b"\xd7")
            elif L == 16:
                self._buffer.write(b"\xd8")
            elif L <= 0xFF:
                self._buffer.write(struct.pack(">BB", 0xC7, L))
            elif L <= 0xFFFF:
                self._buffer.write(struct.pack(">BH", 0xC8, L))
            else:
                self._buffer.write(struct.pack(">BI", 0xC9, L))
            self._buffer.write(struct.pack("b", code))
            self._buffer.write(data)
            return
        if check(obj, list_types):
            n = len(obj)
            self._pack_array_header(n)
            for i in xrange(n):
                self._pack(obj[i], nest_limit - 1)
            return
        if check(obj, dict):
            return self._pack_map_pairs(
                len(obj), dict_iteritems(obj), nest_limit - 1
            )

        if self._datetime and check(obj, _DateTime) and obj.tzinfo is not None:
            obj = Timestamp.from_datetime(obj)
            default_used = 1
            continue

        if not default_used and self._default is not None:
            obj = self._default(obj)
            default_used = 1
            continue

        if self._datetime and check(obj, _DateTime):
            raise ValueError("Cannot serialize %r where tzinfo=None" % (obj,))

        raise TypeError("Cannot serialize %r" % (obj,))

def pack(self, obj):
    try:
        self._pack(obj)
    except:
        self._buffer = StringIO()  # force reset
        raise
    if self._autoreset:
        ret = self._buffer.getvalue()
        self._buffer = StringIO()
        return ret

def pack_map_pairs(self, pairs):
    self._pack_map_pairs(len(pairs), pairs)
    if self._autoreset:
        ret = self._buffer.getvalue()
        self._buffer = StringIO()
        return ret

def pack_array_header(self, n):
    if n >= 2**32:
        raise ValueError
    self._pack_array_header(n)
    if self._autoreset:
        ret = self._buffer.getvalue()
        self._buffer = StringIO()
        return ret

def pack_map_header(self, n):
    if n >= 2**32:
        raise ValueError
    self._pack_map_header(n)
    if self._autoreset:
        ret = self._buffer.getvalue()
        self._buffer = StringIO()
        return ret

def pack_ext_type(self, typecode, data):
    if not isinstance(typecode, int):
        raise TypeError("typecode must have int type.")
    if not 0 <= typecode <= 127:
        raise ValueError("typecode should be 0-127")
    if not isinstance(data, bytes):
        raise TypeError("data must have bytes type")
    L = len(data)
    if L > 0xFFFFFFFF:
        raise ValueError("Too large data")
    if L == 1:
        self._buffer.write(b"\xd4")
    elif L == 2:
        self._buffer.write(b"\xd5")
    elif L == 4:
        self._buffer.write(b"\xd6")
    elif L == 8:
        self._buffer.write(b"\xd7")
    elif L == 16:
        self._buffer.write(b"\xd8")
    elif L <= 0xFF:
        self._buffer.write(b"\xc7" + struct.pack("B", L))
    elif L <= 0xFFFF:
        self._buffer.write(b"\xc8" + struct.pack(">H", L))
    else:
        self._buffer.write(b"\xc9" + struct.pack(">I", L))
    self._buffer.write(struct.pack("B", typecode))
    self._buffer.write(data)

def _pack_array_header(self, n):
    if n <= 0x0F:
        return self._buffer.write(struct.pack("B", 0x90 + n))
    if n <= 0xFFFF:
        return self._buffer.write(struct.pack(">BH", 0xDC, n))
    if n <= 0xFFFFFFFF:
        return self._buffer.write(struct.pack(">BI", 0xDD, n))
    raise ValueError("Array is too large")

def _pack_map_header(self, n):
    if n <= 0x0F:
        return self._buffer.write(struct.pack("B", 0x80 + n))
    if n <= 0xFFFF:
        return self._buffer.write(struct.pack(">BH", 0xDE, n))
    if n <= 0xFFFFFFFF:
        return self._buffer.write(struct.pack(">BI", 0xDF, n))
    raise ValueError("Dict is too large")

def _pack_map_pairs(self, n, pairs, nest_limit=DEFAULT_RECURSE_LIMIT):
    self._pack_map_header(n)
    for (k, v) in pairs:
        self._pack(k, nest_limit - 1)
        self._pack(v, nest_limit - 1)

def _pack_raw_header(self, n):
    if n <= 0x1F:
        self._buffer.write(struct.pack("B", 0xA0 + n))
    elif self._use_bin_type and n <= 0xFF:
        self._buffer.write(struct.pack(">BB", 0xD9, n))
    elif n <= 0xFFFF:
        self._buffer.write(struct.pack(">BH", 0xDA, n))
    elif n <= 0xFFFFFFFF:
        self._buffer.write(struct.pack(">BI", 0xDB, n))
    else:
        raise ValueError("Raw is too large")

def _pack_bin_header(self, n):
    if not self._use_bin_type:
        return self._pack_raw_header(n)
    elif n <= 0xFF:
        return self._buffer.write(struct.pack(">BB", 0xC4, n))
    elif n <= 0xFFFF:
        return self._buffer.write(struct.pack(">BH", 0xC5, n))
    elif n <= 0xFFFFFFFF:
        return self._buffer.write(struct.pack(">BI", 0xC6, n))
    else:
        raise ValueError("Bin is too large")

def bytes(self):
    """Return internal buffer contents as bytes object"""
    return self._buffer.getvalue()

def reset(self):
    """Reset internal buffer.

    This method is useful only when autoreset=False.
    """
    self._buffer = StringIO()

def getbuffer(self):
    """Return view of internal buffer."""
    if USING_STRINGBUILDER or PY2:
        return memoryview(self.bytes())
    else:
        return self._buffer.getbuffer()


