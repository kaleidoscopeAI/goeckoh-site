"""
Forward declaration of an expression to be defined later -
used for recursive grammars, such as algebraic infix notation.
When the expression is known, it is assigned to the ``Forward``
variable using the ``'<<'`` operator.

Note: take care when assigning to ``Forward`` not to overlook
precedence of operators.

Specifically, ``'|'`` has a lower precedence than ``'<<'``, so that::

    fwd_expr << a | b | c

will actually be evaluated as::

    (fwd_expr << a) | b | c

thereby leaving b and c out as parseable alternatives.  It is recommended that you
explicitly group the values inserted into the ``Forward``::

    fwd_expr << (a | b | c)

Converting to use the ``'<<='`` operator instead will avoid this problem.

See :class:`ParseResults.pprint` for an example of a recursive
parser created using ``Forward``.
"""

def __init__(self, other: typing.Optional[Union[ParserElement, str]] = None):
    self.caller_frame = traceback.extract_stack(limit=2)[0]
    super().__init__(other, savelist=False)  # type: ignore[arg-type]
    self.lshift_line = None

def __lshift__(self, other) -> "Forward":
    if hasattr(self, "caller_frame"):
        del self.caller_frame
    if isinstance(other, str_type):
        other = self._literalStringClass(other)

    if not isinstance(other, ParserElement):
        return NotImplemented

    self.expr = other
    self.streamlined = other.streamlined
    self.mayIndexError = self.expr.mayIndexError
    self.mayReturnEmpty = self.expr.mayReturnEmpty
    self.set_whitespace_chars(
        self.expr.whiteChars, copy_defaults=self.expr.copyDefaultWhiteChars
    )
    self.skipWhitespace = self.expr.skipWhitespace
    self.saveAsList = self.expr.saveAsList
    self.ignoreExprs.extend(self.expr.ignoreExprs)
    self.lshift_line = traceback.extract_stack(limit=2)[-2]  # type: ignore[assignment]
    return self

def __ilshift__(self, other) -> "Forward":
    if not isinstance(other, ParserElement):
        return NotImplemented

    return self << other

def __or__(self, other) -> "ParserElement":
    caller_line = traceback.extract_stack(limit=2)[-2]
    if (
        __diag__.warn_on_match_first_with_lshift_operator
        and caller_line == self.lshift_line
        and Diagnostics.warn_on_match_first_with_lshift_operator
        not in self.suppress_warnings_
    ):
        warnings.warn(
            "using '<<' operator with '|' is probably an error, use '<<='",
            stacklevel=2,
        )
    ret = super().__or__(other)
    return ret

def __del__(self):
    # see if we are getting dropped because of '=' reassignment of var instead of '<<=' or '<<'
    if (
        self.expr is None
        and __diag__.warn_on_assignment_to_Forward
        and Diagnostics.warn_on_assignment_to_Forward not in self.suppress_warnings_
    ):
        warnings.warn_explicit(
            "Forward defined here but no expression attached later using '<<=' or '<<'",
            UserWarning,
            filename=self.caller_frame.filename,
            lineno=self.caller_frame.lineno,
        )

def parseImpl(self, instring, loc, doActions=True):
    if (
        self.expr is None
        and __diag__.warn_on_parse_using_empty_Forward
        and Diagnostics.warn_on_parse_using_empty_Forward
        not in self.suppress_warnings_
    ):
        # walk stack until parse_string, scan_string, search_string, or transform_string is found
        parse_fns = (
            "parse_string",
            "scan_string",
            "search_string",
            "transform_string",
        )
        tb = traceback.extract_stack(limit=200)
        for i, frm in enumerate(reversed(tb), start=1):
            if frm.name in parse_fns:
                stacklevel = i + 1
                break
        else:
            stacklevel = 2
        warnings.warn(
            "Forward expression was never assigned a value, will not parse any input",
            stacklevel=stacklevel,
        )
    if not ParserElement._left_recursion_enabled:
        return super().parseImpl(instring, loc, doActions)
    # ## Bounded Recursion algorithm ##
    # Recursion only needs to be processed at ``Forward`` elements, since they are
    # the only ones that can actually refer to themselves. The general idea is
    # to handle recursion stepwise: We start at no recursion, then recurse once,
    # recurse twice, ..., until more recursion offers no benefit (we hit the bound).
    #
    # The "trick" here is that each ``Forward`` gets evaluated in two contexts
    # - to *match* a specific recursion level, and
    # - to *search* the bounded recursion level
    # and the two run concurrently. The *search* must *match* each recursion level
    # to find the best possible match. This is handled by a memo table, which
    # provides the previous match to the next level match attempt.
    #
    # See also "Left Recursion in Parsing Expression Grammars", Medeiros et al.
    #
    # There is a complication since we not only *parse* but also *transform* via
    # actions: We do not want to run the actions too often while expanding. Thus,
    # we expand using `doActions=False` and only run `doActions=True` if the next
    # recursion level is acceptable.
    with ParserElement.recursion_lock:
        memo = ParserElement.recursion_memos
        try:
            # we are parsing at a specific recursion expansion - use it as-is
            prev_loc, prev_result = memo[loc, self, doActions]
            if isinstance(prev_result, Exception):
                raise prev_result
            return prev_loc, prev_result.copy()
        except KeyError:
            act_key = (loc, self, True)
            peek_key = (loc, self, False)
            # we are searching for the best recursion expansion - keep on improving
            # both `doActions` cases must be tracked separately here!
            prev_loc, prev_peek = memo[peek_key] = (
                loc - 1,
                ParseException(
                    instring, loc, "Forward recursion without base case", self
                ),
            )
            if doActions:
                memo[act_key] = memo[peek_key]
            while True:
                try:
                    new_loc, new_peek = super().parseImpl(instring, loc, False)
                except ParseException:
                    # we failed before getting any match â€“ do not hide the error
                    if isinstance(prev_peek, Exception):
                        raise
                    new_loc, new_peek = prev_loc, prev_peek
                # the match did not get better: we are done
                if new_loc <= prev_loc:
                    if doActions:
                        # replace the match for doActions=False as well,
                        # in case the action did backtrack
                        prev_loc, prev_result = memo[peek_key] = memo[act_key]
                        del memo[peek_key], memo[act_key]
                        return prev_loc, prev_result.copy()
                    del memo[peek_key]
                    return prev_loc, prev_peek.copy()
                # the match did get better: see if we can improve further
                else:
                    if doActions:
                        try:
                            memo[act_key] = super().parseImpl(instring, loc, True)
                        except ParseException as e:
                            memo[peek_key] = memo[act_key] = (new_loc, e)
                            raise
                    prev_loc, prev_peek = memo[peek_key] = new_loc, new_peek

def leave_whitespace(self, recursive: bool = True) -> ParserElement:
    self.skipWhitespace = False
    return self

def ignore_whitespace(self, recursive: bool = True) -> ParserElement:
    self.skipWhitespace = True
    return self

def streamline(self) -> ParserElement:
    if not self.streamlined:
        self.streamlined = True
        if self.expr is not None:
            self.expr.streamline()
    return self

def validate(self, validateTrace=None) -> None:
    warnings.warn(
        "ParserElement.validate() is deprecated, and should not be used to check for left recursion",
        DeprecationWarning,
        stacklevel=2,
    )
    if validateTrace is None:
        validateTrace = []

    if self not in validateTrace:
        tmp = validateTrace[:] + [self]
        if self.expr is not None:
            self.expr.validate(tmp)
    self._checkRecursion([])

def _generateDefaultName(self) -> str:
    # Avoid infinite recursion by setting a temporary _defaultName
    self._defaultName = ": ..."

    # Use the string representation of main expression.
    retString = "..."
    try:
        if self.expr is not None:
            retString = str(self.expr)[:1000]
        else:
            retString = "None"
    finally:
        return self.__class__.__name__ + ": " + retString

def copy(self) -> ParserElement:
    if self.expr is not None:
        return super().copy()
    else:
        ret = Forward()
        ret <<= self
        return ret

def _setResultsName(self, name, list_all_matches=False):
    if (
        __diag__.warn_name_set_on_empty_Forward
        and Diagnostics.warn_name_set_on_empty_Forward
        not in self.suppress_warnings_
    ):
        if self.expr is None:
            warnings.warn(
                "{}: setting results name {!r} on {} expression "
                "that has no contained expression".format(
                    "warn_name_set_on_empty_Forward", name, type(self).__name__
                ),
                stacklevel=3,
            )

    return super()._setResultsName(name, list_all_matches)

# Compatibility synonyms
# fmt: off
@replaced_by_pep8(leave_whitespace)
def leaveWhitespace(self): ...

@replaced_by_pep8(ignore_whitespace)
def ignoreWhitespace(self): ...
# fmt: on


