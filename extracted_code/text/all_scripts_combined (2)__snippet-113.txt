if tts_wav.ndim > 1:
    tts_wav = np.mean(tts_wav, axis=1)
tts_wav = np.asarray(tts_wav, dtype=np.float32)

frame_length = max(int(tts_sample_rate * (prosody.frame_length / prosody.sample_rate)), 256)
hop_length = max(int(tts_sample_rate * (prosody.hop_length / prosody.sample_rate)), 128)
num_frames = 1 + max(0, (len(tts_wav) - frame_length) // hop_length)
if num_frames <= 0:
    return tts_wav

f0_child = _interp_to_num_frames(prosody.f0_hz, num_frames)
energy_child = _interp_to_num_frames(prosody.energy, num_frames)

try:
    f0_tts = librosa.yin(
        tts_wav,
        fmin=80.0,
        fmax=600.0,
        sr=tts_sample_rate,
        frame_length=frame_length,
        hop_length=hop_length,
    )
    voiced = f0_tts > 0
    if np.any(voiced):
        base_f0 = float(np.median(f0_tts[voiced]))
    else:
        base_f0 = float(np.median(f0_child))
except Exception:
    base_f0 = float(np.median(f0_child))

out = np.zeros(len(tts_wav) + frame_length, dtype=np.float32)
window = np.hanning(frame_length).astype(np.float32)
eps = 1e-6

for i in range(num_frames):
    start = i * hop_length
    end = start + frame_length
    if start >= len(tts_wav):
        break
    frame = tts_wav[start:end]
    if len(frame) < frame_length:
        frame = np.pad(frame, (0, frame_length - len(frame)), mode="constant")

    target_f0 = float(f0_child[i])
    if base_f0 > 0:
        raw_ratio = target_f0 / base_f0
    else:
        raw_ratio = 1.0
    pitch_ratio = raw_ratio ** strength_pitch
    n_steps = 12.0 * np.log2(max(pitch_ratio, 1e-3))
    try:
        shifted = librosa.effects.pitch_shift(
            frame,
            sr=tts_sample_rate,
            n_steps=n_steps,
        )
    except Exception:
        shifted = frame
    if shifted.shape[0] != frame_length:
        if shifted.shape[0] > frame_length:
            shifted = shifted[:frame_length]
        else:
            shifted = np.pad(shifted, (0, frame_length - shifted.shape[0]))
    frame_rms = float(np.sqrt(np.mean(np.square(shifted)) + eps))
    target_rms = float(energy_child[i])
    if frame_rms > 0:
        ratio = (target_rms / frame_rms) ** strength_energy
    else:
        ratio = 1.0
    shifted *= ratio
    out[start:end] += shifted * window

max_abs = float(np.max(np.abs(out)) + eps)
if max_abs > 1.0:
    out = out / max_abs
return out.astype(np.float32)
