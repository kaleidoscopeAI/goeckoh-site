   // hash + value noise
   float hash(vec3 p){
     p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
     p *= 17.0;
     return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
   }
   float noise(vec3 p){
     vec3 i = floor(p);
     vec3 f = fract(p);
     f = f*f*(3.0-2.0*f);
     float n000 = hash(i + vec3(0,0,0));
     float n100 = hash(i + vec3(1,0,0));
     float n010 = hash(i + vec3(0,1,0));
     float n110 = hash(i + vec3(1,1,0));
     float n001 = hash(i + vec3(0,0,1));
     float n101 = hash(i + vec3(1,0,1));
     float n011 = hash(i + vec3(0,1,1));
     float n111 = hash(i + vec3(1,1,1));
     float nx00 = mix(n000, n100, f.x);
     float nx10 = mix(n010, n110, f.x);
     float nx01 = mix(n001, n101, f.x);
     float nx11 = mix(n011, n111, f.x);
     float nxy0 = mix(nx00, nx10, f.y);
     float nxy1 = mix(nx01, nx11, f.y);
     return mix(nxy0, nxy1, f.z);
   }`
)
.replace(
  "#include <begin_vertex>",
  `#include <begin_vertex>
   // Displace along normal: smooth wobble + spiky component.
   // uSpike in [0..1] controls spikiness.
   vec3 p = position;
   vec3 n = normalize(normal);
   float t = uTime;

   float base = noise(p * 1.6 + vec3(0.0, 0.0, t * 0.35));
   float wob = noise(p * 3.4 + vec3(t * 0.25, -t * 0.18, t * 0.22));
   float spk = noise(p * 10.0 + vec3(t * 0.45, t * 0.31, -t * 0.27));

   float wobble = (base * 0.55 + wob * 0.45) - 0.5;
   float spikes = (spk - 0.5);

   float disp = uWobble * wobble + uDisp * uSpike * spikes;
   transformed += n * disp;`
);
};

