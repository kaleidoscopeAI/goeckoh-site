"""
Convert a pyparsing element tree into a list of diagrams. This is the recommended entrypoint to diagram
creation if you want to access the Railroad tree before it is converted to HTML
:param element: base element of the parser being diagrammed
:param diagram_kwargs: kwargs to pass to the Diagram() constructor
:param vertical: (optional) - int - limit at which number of alternatives should be
   shown vertically instead of horizontally
:param show_results_names - bool to indicate whether results name annotations should be
   included in the diagram
:param show_groups - bool to indicate whether groups should be highlighted with an unlabeled
   surrounding box
"""
# Convert the whole tree underneath the root
lookup = ConverterState(diagram_kwargs=diagram_kwargs or {})
_to_diagram_element(
    element,
    lookup=lookup,
    parent=None,
    vertical=vertical,
    show_results_names=show_results_names,
    show_groups=show_groups,
)

root_id = id(element)
# Convert the root if it hasn't been already
if root_id in lookup:
    if not element.customName:
        lookup[root_id].name = ""
    lookup[root_id].mark_for_extraction(root_id, lookup, force=True)

# Now that we're finished, we can convert from intermediate structures into Railroad elements
diags = list(lookup.diagrams.values())
if len(diags) > 1:
    # collapse out duplicate diags with the same name
    seen = set()
    deduped_diags = []
    for d in diags:
        # don't extract SkipTo elements, they are uninformative as subdiagrams
        if d.name == "...":
            continue
        if d.name is not None and d.name not in seen:
            seen.add(d.name)
            deduped_diags.append(d)
    resolved = [resolve_partial(partial) for partial in deduped_diags]
else:
    # special case - if just one diagram, always display it, even if
    # it has no name
    resolved = [resolve_partial(partial) for partial in diags]
return sorted(resolved, key=lambda diag: diag.index)


