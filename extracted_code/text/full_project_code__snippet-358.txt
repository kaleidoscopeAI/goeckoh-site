"""
Given an PyOpenSSL certificate, provides all the subject alternative names.
"""
# Pass the cert to cryptography, which has much better APIs for this.
if hasattr(peer_cert, "to_cryptography"):
    cert = peer_cert.to_cryptography()
else:
    der = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, peer_cert)
    cert = x509.load_der_x509_certificate(der, openssl_backend)

# We want to find the SAN extension. Ask Cryptography to locate it (it's
# faster than looping in Python)
try:
    ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value
except x509.ExtensionNotFound:
    # No such extension, return the empty list.
    return []
except (
    x509.DuplicateExtension,
    UnsupportedExtension,
    x509.UnsupportedGeneralNameType,
    UnicodeError,
) as e:
    # A problem has been found with the quality of the certificate. Assume
    # no SAN field is present.
    log.warning(
        "A problem was encountered with the certificate that prevented "
        "urllib3 from finding the SubjectAlternativeName field. This can "
        "affect certificate validation. The error was %s",
        e,
    )
    return []

# We want to return dNSName and iPAddress fields. We need to cast the IPs
# back to strings because the match_hostname function wants them as
# strings.
# Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8
# decoded. This is pretty frustrating, but that's what the standard library
# does with certificates, and so we need to attempt to do the same.
# We also want to skip over names which cannot be idna encoded.
names = [
    ("DNS", name)
    for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))
    if name is not None
]
names.extend(
    ("IP Address", str(name)) for name in ext.get_values_for_type(x509.IPAddress)
)

return names


