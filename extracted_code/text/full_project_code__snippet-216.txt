"""Percent-encodes a URI component without reapplying
onto an already percent-encoded component.
"""
if component is None:
    return component

component = six.ensure_text(component)

# Normalize existing percent-encoded bytes.
# Try to see if the component we're encoding is already percent-encoded
# so we can skip all '%' characters but still encode all others.
component, percent_encodings = PERCENT_RE.subn(
    lambda match: match.group(0).upper(), component
)

uri_bytes = component.encode("utf-8", "surrogatepass")
is_percent_encoded = percent_encodings == uri_bytes.count(b"%")
encoded_component = bytearray()

for i in range(0, len(uri_bytes)):
    # Will return a single character bytestring on both Python 2 & 3
    byte = uri_bytes[i : i + 1]
    byte_ord = ord(byte)
    if (is_percent_encoded and byte == b"%") or (
        byte_ord < 128 and byte.decode() in allowed_chars
    ):
        encoded_component += byte
        continue
    encoded_component.extend(b"%" + (hex(byte_ord)[2:].encode().zfill(2).upper()))

return encoded_component.decode(encoding)


