"""Returns a tuple of 2 sets of which paths to display to user

The first set contains paths that would be deleted. Files of a package
are not added and the top-level directory of the package has a '*' added
at the end - to signify that all it's contents are removed.

The second set contains files that would have been skipped in the above
folders.
"""

will_remove = set(paths)
will_skip = set()

# Determine folders and files
folders = set()
files = set()
for path in will_remove:
    if path.endswith(".pyc"):
        continue
    if path.endswith("__init__.py") or ".dist-info" in path:
        folders.add(os.path.dirname(path))
    files.add(path)

_normcased_files = set(map(os.path.normcase, files))

folders = compact(folders)

# This walks the tree using os.walk to not miss extra folders
# that might get added.
for folder in folders:
    for dirpath, _, dirfiles in os.walk(folder):
        for fname in dirfiles:
            if fname.endswith(".pyc"):
                continue

            file_ = os.path.join(dirpath, fname)
            if (
                os.path.isfile(file_)
                and os.path.normcase(file_) not in _normcased_files
            ):
                # We are skipping this file. Add it to the set.
                will_skip.add(file_)

will_remove = files | {os.path.join(folder, "*") for folder in folders}

return will_remove, will_skip


