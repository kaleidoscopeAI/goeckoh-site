if is_url(name):
    marker_sep = "; "
else:
    marker_sep = ";"
if marker_sep in name:
    name, markers_as_string = name.split(marker_sep, 1)
    markers_as_string = markers_as_string.strip()
    if not markers_as_string:
        markers = None
    else:
        markers = Marker(markers_as_string)
else:
    markers = None
name = name.strip()
req_as_string = None
path = os.path.normpath(os.path.abspath(name))
link = None
extras_as_string = None

if is_url(name):
    link = Link(name)
else:
    p, extras_as_string = _strip_extras(path)
    url = _get_url_from_path(p, name)
    if url is not None:
        link = Link(url)

# it's a local file, dir, or url
if link:
    # Handle relative file URLs
    if link.scheme == "file" and re.search(r"\.\./", link.url):
        link = Link(path_to_url(os.path.normpath(os.path.abspath(link.path))))
    # wheel file
    if link.is_wheel:
        wheel = Wheel(link.filename)  # can raise InvalidWheelFilename
        req_as_string = f"{wheel.name}=={wheel.version}"
    else:
        # set the req to the egg fragment.  when it's not there, this
        # will become an 'unnamed' requirement
        req_as_string = link.egg_fragment

# a requirement specifier
else:
    req_as_string = name

extras = convert_extras(extras_as_string)

def with_source(text: str) -> str:
    if not line_source:
        return text
    return f"{text} (from {line_source})"

def _parse_req_string(req_as_string: str) -> Requirement:
    try:
        req = get_requirement(req_as_string)
    except InvalidRequirement:
        if os.path.sep in req_as_string:
            add_msg = "It looks like a path."
            add_msg += deduce_helpful_msg(req_as_string)
        elif "=" in req_as_string and not any(
            op in req_as_string for op in operators
        ):
            add_msg = "= is not a valid operator. Did you mean == ?"
        else:
            add_msg = ""
        msg = with_source(f"Invalid requirement: {req_as_string!r}")
        if add_msg:
            msg += f"\nHint: {add_msg}"
        raise InstallationError(msg)
    else:
        # Deprecate extras after specifiers: "name>=1.0[extras]"
        # This currently works by accident because _strip_extras() parses
        # any extras in the end of the string and those are saved in
        # RequirementParts
        for spec in req.specifier:
            spec_str = str(spec)
            if spec_str.endswith("]"):
                msg = f"Extras after version '{spec_str}'."
                raise InstallationError(msg)
    return req

if req_as_string is not None:
    req: Optional[Requirement] = _parse_req_string(req_as_string)
else:
    req = None

return RequirementParts(req, link, markers, extras)


