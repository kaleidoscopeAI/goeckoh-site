"""
(DEPRECATED - use :class:`IndentedBlock` class instead)
Helper method for defining space-delimited indentation blocks,
such as those used to define block statements in Python source code.

Parameters:

- ``blockStatementExpr`` - expression defining syntax of statement that
  is repeated within the indented block
- ``indentStack`` - list created by caller to manage indentation stack
  (multiple ``statementWithIndentedBlock`` expressions within a single
  grammar should share a common ``indentStack``)
- ``indent`` - boolean indicating whether block must be indented beyond
  the current level; set to ``False`` for block of left-most statements
  (default= ``True``)

A valid block must contain at least one ``blockStatement``.

(Note that indentedBlock uses internal parse actions which make it
incompatible with packrat parsing.)

Example::

    data = '''
    def A(z):
      A1
      B = 100
      G = A2
      A2
      A3
    B
    def BB(a,b,c):
      BB1
      def BBA():
        bba1
        bba2
        bba3
    C
    D
    def spam(x,y):
         def eggs(z):
             pass
    '''


    indentStack = [1]
    stmt = Forward()

    identifier = Word(alphas, alphanums)
    funcDecl = ("def" + identifier + Group("(" + Opt(delimitedList(identifier)) + ")") + ":")
    func_body = indentedBlock(stmt, indentStack)
    funcDef = Group(funcDecl + func_body)

    rvalue = Forward()
    funcCall = Group(identifier + "(" + Opt(delimitedList(rvalue)) + ")")
    rvalue << (funcCall | identifier | Word(nums))
    assignment = Group(identifier + "=" + rvalue)
    stmt << (funcDef | assignment | identifier)

    module_body = stmt[1, ...]

    parseTree = module_body.parseString(data)
    parseTree.pprint()

prints::

    [['def',
      'A',
      ['(', 'z', ')'],
      ':',
      [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],
     'B',
     ['def',
      'BB',
      ['(', 'a', 'b', 'c', ')'],
      ':',
      [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],
     'C',
     'D',
     ['def',
      'spam',
      ['(', 'x', 'y', ')'],
      ':',
      [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]]
"""
backup_stacks.append(indentStack[:])

def reset_stack():
    indentStack[:] = backup_stacks[-1]

def checkPeerIndent(s, l, t):
    if l >= len(s):
        return
    curCol = col(l, s)
    if curCol != indentStack[-1]:
        if curCol > indentStack[-1]:
            raise ParseException(s, l, "illegal nesting")
        raise ParseException(s, l, "not a peer entry")

def checkSubIndent(s, l, t):
    curCol = col(l, s)
    if curCol > indentStack[-1]:
        indentStack.append(curCol)
    else:
        raise ParseException(s, l, "not a subentry")

def checkUnindent(s, l, t):
    if l >= len(s):
        return
    curCol = col(l, s)
    if not (indentStack and curCol in indentStack):
        raise ParseException(s, l, "not an unindent")
    if curCol < indentStack[-1]:
        indentStack.pop()

NL = OneOrMore(LineEnd().set_whitespace_chars("\t ").suppress())
INDENT = (Empty() + Empty().set_parse_action(checkSubIndent)).set_name("INDENT")
PEER = Empty().set_parse_action(checkPeerIndent).set_name("")
UNDENT = Empty().set_parse_action(checkUnindent).set_name("UNINDENT")
if indent:
    smExpr = Group(
        Opt(NL)
        + INDENT
        + OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))
        + UNDENT
    )
else:
    smExpr = Group(
        Opt(NL)
        + OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))
        + Opt(UNDENT)
    )

# add a parse action to remove backup_stack from list of backups
smExpr.add_parse_action(
    lambda: backup_stacks.pop(-1) and None if backup_stacks else None
)
smExpr.set_fail_action(lambda a, b, c, d: reset_stack())
blockStatementExpr.ignore(_bslash + LineEnd())
return smExpr.set_name("indented block")


