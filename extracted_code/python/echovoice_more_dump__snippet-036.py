            ▪ Disadvantages: HTML elements rendered via CSS2DRenderer exist in a separate layer on top of the WebGL canvas.51 They do not naturally occlude behind other 3D objects, requiring complex workarounds (blending, raycasting) or potentially external libraries to achieve correct depth sorting.52 Performance can degrade with a large number of DOM elements 53, and scaling behavior might differ from WebGL objects.54 While suitable for a few labels, it may not scale well to many dynamic thoughts.53
        ◦ THREE.Sprite + THREE.CanvasTexture: This technique involves rendering the text onto an offscreen HTML5 Canvas element and then using that canvas as a texture applied to a THREE.Sprite object.51 Sprites are essentially 2D planes in 3D space that always face the camera.
            ▪ Advantages: Sprites are part of the WebGL scene graph, meaning they correctly interact with depth testing and occlusion by other 3D objects.51 This provides better visual integration. Performance can be better than many DOM elements if optimized, particularly by using texture atlases.49
            ▪ Disadvantages: Text rendered on a canvas may appear less crisp than native HTML text, especially at different resolutions.59 Dynamically updating the text requires redrawing the canvas and signaling the texture needs updating (texture.needsUpdate = true), which can be a significant performance bottleneck if done frequently for many sprites.56 Creating a new canvas element for each label is inefficient 56; reusing a single canvas or, preferably, implementing a texture atlas (drawing multiple labels onto one larger canvas texture and using UV coordinates to select the correct portion for each sprite) is crucial for performance.49 Even with optimizations, managing hundreds of dynamic sprites can be challenging.48
        ◦ THREE.TextGeometry: Creates 3D mesh geometry from text outlines. Generally unsuitable for numerous labels due to high polygon count and performance cost.51
