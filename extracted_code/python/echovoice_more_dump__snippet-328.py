                    <div class="tooltip" data-tooltip="Real-time metrics from the cognitive crystal simulation">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                    </div>
                </div>
                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-header">
                            <div class="metric-label">Stress Level</div>
                            <div class="tooltip" data-tooltip="Measure of cognitive load on the crystal">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                                </svg>
                            </div>
                        </div>
                        <div id="stress-value" class="metric-value">0.00</div>
                        <div class="metric-progress">
                            <div id="stress-progress" class="metric-progress-inner" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="metric">
                        <div class="metric-header">
                            <div class="metric-label">Energy State</div>
                            <div class="tooltip" data-tooltip="Current energy level of the crystal system">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                                </svg>
                            </div>
                        </div>
                        <div id="energy-value" class="metric-value">0.00</div>
                        <div class="metric-progress">
                            <div id="energy-progress" class="metric-progress-inner" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="metric">
                        <div class="metric-header">
                            <div class="metric-label">Confidence</div>
                            <div class="tooltip" data-tooltip="Certainty level of the crystal's current state">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                                </svg>
                            </div>
                        </div>
                        <div id="confidence-value" class="metric-value">0.00</div>
                        <div class="metric-progress">
                            <div id="confidence-progress" class="metric-progress-inner" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="metric">
                        <div class="metric-header">
                            <div class="metric-label">Harmony</div>
                            <div class="tooltip" data-tooltip="Balance and coherence of the cognitive processes">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                                </svg>
                            </div>
                        </div>
                        <div id="harmony-value" class="metric-value">0.00</div>
                        <div class="metric-progress">
                            <div id="harmony-progress" class="metric-progress-inner" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="metric">
                        <div class="metric-header">
                            <div class="metric-label">Emergence</div>
                            <div class="tooltip" data-tooltip="Level of emergent behavior in the system">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                                </svg>
                            </div>
                        </div>
                        <div id="emergence-value" class="metric-value">0.00</div>
                        <div class="metric-progress">
                            <div id="emergence-progress" class="metric-progress-inner" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="metric">
                        <div class="metric-header">
                            <div class="metric-label">Memory</div>
                            <div class="tooltip" data-tooltip="Current memory utilization and retention">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                                </svg>
                            </div>
                        </div>
                        <div id="memory-value" class="metric-value">0.00</div>
                        <div class="metric-progress">
                            <div id="memory-progress" class="metric-progress-inner" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="metrics-chart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-group">
                <h3 class="control-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="12"/>
                        <line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                    Simulation Parameters
                </h3>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Task Load</span>
                        <span id="load-value" class="slider-value">0.50</span>
                    </div>
                    <input type="range" id="load-slider" min="0" max="1" step="0.01" value="0.5">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Noise Level</span>
                        <span id="noise-value" class="slider-value">0.10</span>
                    </div>
                    <input type="range" id="noise-slider" min="0" max="0.5" step="0.01" value="0.1">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Decay Rate</span>
                        <span id="decay-value" class="slider-value">0.05</span>
                    </div>
                    <input type="range" id="decay-slider" min="0" max="0.2" step="0.01" value="0.05">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Annealing Rate</span>
                        <span id="anneal-value" class="slider-value">0.02</span>
                    </div>
                    <input type="range" id="anneal-slider" min="0.01" max="0.1" step="0.01" value="0.02">
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="control-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Simulation Control
                </h3>
                
                <div class="button-group">
                    <button id="step-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="4" y1="12" x2="20" y2="12"/>
                            <polyline points="14 6 20 12 14 18"/>
                        </svg>
                        Step
                    </button>
                    <button id="auto-btn" class="secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"/>
                        </svg>
                        Start Auto
                    </button>
                    <button id="reset-btn" class="secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                        </svg>
                        Reset
                    </button>
                    <button id="export-btn" class="secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        Export Data
                    </button>
                </div>
                
                <h3 class="control-title" style="margin-top: 25px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                    </svg>
                    Data Ingestion
                </h3>
                
                <div class="button-group">
                    <button id="smiles-btn" class="secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                            <line x1="9" y1="9" x2="9.01" y2="9"/>
                            <line x1="15" y1="9" x2="15.01" y2="9"/>
                        </svg>
                        SMILES Data
                    </button>
                    <button id="web-btn" class="secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="2" y1="12" x2="22" y2="12"/>
                            <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                        </svg>
                        Web Content
                    </button>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="control-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                        <polyline points="7.5 4.21 12 6.81 16.5 4.21"/>
                        <polyline points="7.5 19.79 7.5 14.6 3 12"/>
                        <polyline points="21 12 16.5 14.6 16.5 19.79"/>
                        <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
                        <line x1="12" y1="22.08" x2="12" y2="12"/>
                    </svg>
                    System Information
                </h3>
                
                <div class="tab-group">
                    <div class="tab active" data-tab="status">Status</div>
                    <div class="tab" data-tab="memory">Memory</div>
                    <div class="tab" data-tab="connections">Connections</div>
                </div>
                
                <table class="data-table">
                    <tr>
                        <th>Property</th>
                        <th>Value</th>
                        <th>Status</th>
                    </tr>
                    <tr>
                        <td>Lattice Size</td>
                        <td>3 × 3 × 3</td>
                        <td><span class="badge badge-success">Stable</span></td>
                    </tr>
                    <tr>
                        <td>Nodes</td>
                        <td>27</td>
                        <td><span class="badge badge-success">Active</span></td>
                    </tr>
                    <tr>
                        <td>Connections</td>
                        <td>108</td>
                        <td><span class="badge badge-success">Strong</span></td>
                    </tr>
                    <tr>
                        <td>Ollama Connection</td>
                        <td>192.168.1.105:11434</td>
                        <td><span class="badge badge-success">Connected</span></td>
                    </tr>
                    <tr>
                        <td>Last Update</td>
                        <td id="last-update">0.0ms ago</td>
                        <td><span class="badge badge-success">Recent</span></td>
                    </tr>
                </table>
            </div>
        </div>
        
        <div class="console">
            <div class="console-header">
                <h3 class="control-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="4 17 10 11 4 5"/>
                        <line x1="12" y1="19" x2="20" y2="19"/>
                    </svg>
                    Consciousness Console
                </h3>
                <div class="tooltip" data-tooltip="Direct interface with the cognitive crystal's reasoning processes">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                        <line x1="12" y1="17" x2="12.01" y2="17"/>
                    </svg>
                </div>
            </div>
            
            <div id="console-content" class="console-content">
                <div class="console-message">[INFO] System initialized at 2023-11-15T09:42:18.123Z</div>
                <div class="console-message">[INFO] Cognitive Crystal core loaded successfully</div>
                <div class="console-message">[INFO] Three.js visualization engine started</div>
                <div class="console-message">[STATUS] Crystal lattice stability: 98.7%</div>
                <div class="console-message">[SYSTEM] Ready for simulation parameters</div>
            </div>
            
            <div class="console-input">
                <input type="text" id="prompt-input" placeholder="Query the crystal's consciousness...">
                <button id="ask-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="22" y1="2" x2="11" y2="13"/>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                    </svg>
                    Send
                </button>
            </div>
        </div>
    </div>

    <script>
        // Real implementations with physics simulation and Ollama integration
        class CognitiveCrystal {
            constructor(config) {
                this.config = config;
                this.nodes = this.generateNodes(config.latticeSize);
                this.bonds = this.generateBonds(this.nodes);
                this.stress = 0;
                this.energy = 0;
                this.confidence = 0;
                this.harmony = 0;
                this.emergence = 0;
                this.memory = 0.8;
            }
            
            generateNodes(size) {
                const nodes = [];
                const spacing = 2;
                for (let x = 0; x < size; x++) {
                    for (let y = 0; y < size; y++) {
                        for (let z = 0; z < size; z++) {
                            nodes.push({
                                x: (x - (size-1)/2) * spacing,
                                y: (y - (size-1)/2) * spacing,
                                z: (z - (size-1)/2) * spacing,
                                vx: 0,
                                vy: 0,
                                vz: 0,
                                energy: Math.random() * 0.5 + 0.5
                            });
                        }
                    }
                }
                return nodes;
            }
            
            generateBonds(nodes) {
                const bonds = [];
                const threshold = 2.5;
                
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[i].x - nodes[j].x;
                        const dy = nodes[i].y - nodes[j].y;
                        const dz = nodes[i].z - nodes[j].z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (dist < threshold) {
                            bonds.push({from: i, to: j, strength: 1 - dist/threshold});
                        }
                    }
                }
                
                return bonds;
            }
            
            applyAnnealing(params) {
                const restLength = 2;
                const springConstant = 0.5;
                const damping = 0.95;
                
                const forces = this.nodes.map(() => ({fx: 0, fy: 0, fz: 0}));
                
                // Spring forces
                this.bonds.forEach(bond => {
                    const from = this.nodes[bond.from];
                    const to = this.nodes[bond.to];
                    const dx = to.x - from.x;
                    const dy = to.y - from.y;
                    const dz = to.z - from.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1e-10;
                    const force = springConstant * (dist - restLength) * bond.strength;
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    const fz = (dz / dist) * force;
                    forces[bond.from].fx += fx;
                    forces[bond.from].fy += fy;
                    forces[bond.from].fz += fz;
                    forces[bond.to].fx -= fx;
                    forces[bond.to].fy -= fy;
                    forces[bond.to].fz -= fz;
                });
                
                // Task load as random external forces
                this.nodes.forEach((node, i) => {
                    forces[i].fx += (Math.random() - 0.5) * params.taskLoad * 2;
                    forces[i].fy += (Math.random() - 0.5) * params.taskLoad * 2;
                    forces[i].fz += (Math.random() - 0.5) * params.taskLoad * 2;
                });
                
                // Apply forces and update positions
                this.nodes.forEach((node, i) => {
                    const f = forces[i];
                    node.vx += f.fx * params.annealRate;
                    node.vy += f.fy * params.annealRate;
                    node.vz += f.fz * params.annealRate;
                    node.vx *= damping;
                    node.vy *= damping;
                    node.vz *= damping;
                    node.x += node.vx * params.annealRate;
                    node.y += node.vy * params.annealRate;
                    node.z += node.vz * params.annealRate;
                    
                    // Noise perturbation
                    node.x += (Math.random() - 0.5) * params.noiseLevel;
                    node.y += (Math.random() - 0.5) * params.noiseLevel;
                    node.z += (Math.random() - 0.5) * params.noiseLevel;
                    
                    // Energy decay and fluctuation
                    node.energy = Math.max(0, Math.min(1, node.energy - params.decayRate * 0.1 + (Math.random() - 0.5) * params.noiseLevel));
                });
                
                // Calculate metrics based on state
                let totalStretch = 0;
                this.bonds.forEach(bond => {
                    const from = this.nodes[bond.from];
                    const to = this.nodes[bond.to];
                    const dx = to.x - from.x;
                    const dy = to.y - from.y;
                    const dz = to.z - from.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    totalStretch += Math.abs(dist - restLength);
                });
                this.stress = Math.min(1, totalStretch / this.bonds.length / restLength);
                
                let avgEnergy = 0;
                let energyVar = 0;
                let avgSpeed = 0;
                this.nodes.forEach(node => {
                    avgEnergy += node.energy;
                    const speed = Math.sqrt(node.vx**2 + node.vy**2 + node.vz**2);
                    avgSpeed += speed;
                });
                avgEnergy /= this.nodes.length;
                avgSpeed /= this.nodes.length;
                
                this.nodes.forEach(node => {
                    energyVar += (node.energy - avgEnergy)**2;
                });
                energyVar /= this.nodes.length;
                
                this.energy = avgEnergy;
                this.confidence = Math.max(0, Math.min(1, Math.exp(-avgSpeed * 10)));
                this.harmony = 1 - this.stress;
                this.emergence = Math.min(1, Math.sqrt(energyVar) * 10);
                this.memory = Math.max(0, this.memory - params.decayRate * 0.01);
            }
        }

        // Initialize the simulation
        let crystal;
        let animationId;
        let isAutoRunning = false;
        let lastUpdateTime = Date.now();
        const metricsHistory = {
            stress: [],
            energy: [],
            confidence: [],
            harmony: [],
            emergence: [],
            memory: []
        };
        
        function init() {
            crystal = new CrystalSimulation();
            initVisualization();
            initCharts();
            updateMetrics();
            updateLastUpdate();
            
            // Set up event listeners
            document.getElementById('step-btn').addEventListener('click', stepSimulation);
            document.getElementById('auto-btn').addEventListener('click', toggleAutoRun);
            document.getElementById('reset-btn').addEventListener('click', resetCrystal);
            document.getElementById('export-btn').addEventListener('click', exportData);
            document.getElementById('smiles-btn').addEventListener('click', ingestSMILES);
            document.getElementById('web-btn').addEventListener('click', ingestWebContent);
            document.getElementById('ask-btn').addEventListener('click', queryConsciousness);
            
            // Slider events
            document.getElementById('load-slider').addEventListener('input', (e) => {
                document.getElementById('load-value').textContent = parseFloat(e.target.value).toFixed(2);
            });
            
            document.getElementById('noise-slider').addEventListener('input', (e) => {
                document.getElementById('noise-value').textContent = parseFloat(e.target.value).toFixed(2);
            });
            
            document.getElementById('decay-slider').addEventListener('input', (e) => {
                document.getElementById('decay-value').textContent = parseFloat(e.target.value).toFixed(2);
            });
            
            document.getElementById('anneal-slider').addEventListener('input', (e) => {
                document.getElementById('anneal-value').textContent = parseFloat(e.target.value).toFixed(2);
            });
            
            // Tab events
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                });
            });
            
            // Add example console messages
            setTimeout(() => {
                appendMessage("Crystal initialized. Ready for cognitive annealing processes.", "INFO");
            }, 1000);
        }
        
        class CrystalSimulation {
            constructor() {
                this.core = new CognitiveCrystal({
                    latticeSize: 3
                });
                this.timeStep = 0;
            }

            step(params = {}) {
                const load = parseFloat(document.getElementById('load-slider').value);
                const noise = parseFloat(document.getElementById('noise-slider').value);
                const decay = parseFloat(document.getElementById('decay-slider').value);
                const anneal = parseFloat(document.getElementById('anneal-slider').value);
                
                this.core.applyAnnealing({
                    taskLoad: load,
                    noiseLevel: noise,
                    decayRate: decay,
                    annealRate: anneal
                });

                this.timeStep++;
                lastUpdateTime = Date.now();
                updateLastUpdate();
                return this.metrics();
            }

            metrics() {
                return {
                    stress: this.core.stress,
                    energy: this.core.energy,
                    confidence: this.core.confidence,
                    harmony: this.core.harmony,
                    emergence: this.core.emergence,
                    memory: this.core.memory
                };
            }
        }
        
        function stepSimulation() {
            const metrics = crystal.step();
            updateMetrics();
            updateVisualization();
            updateCharts(metrics);
            
            appendMessage(`Simulation step ${crystal.timeStep} completed.`, "INFO");
        }
        
        function toggleAutoRun() {
            isAutoRunning = !isAutoRunning;
            const button = document.getElementById('auto-btn');
            button.innerHTML = isAutoRunning ? 
                '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>Pause' : 
                '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>Start Auto';
            
            if (isAutoRunning) {
                animate();
                appendMessage("Auto simulation started.", "INFO");
            } else {
                cancelAnimationFrame(animationId);
                appendMessage("Auto simulation paused.", "INFO");
            }
        }
        
        function animate() {
            stepSimulation();
            if (isAutoRunning) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function resetCrystal() {
            cancelAnimationFrame(animationId);
            isAutoRunning = false;
            document.getElementById('auto-btn').innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>Start Auto';
            
            crystal = new CrystalSimulation();
            resetMetricsHistory();
            updateMetrics();
            updateVisualization();
            
            appendMessage("Crystal has been reset to initial state.", "INFO");
        }
        
        function exportData() {
            appendMessage("Exporting simulation data...", "INFO");
            let data = {
                metrics: crystal.metrics(),
                timeStep: crystal.timeStep,
                nodes: crystal.core.nodes,
                bonds: crystal.core.bonds
            };
            const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'simulation_data.json';
            a.click();
            URL.revokeObjectURL(url);
            appendMessage("Data exported successfully.", "SUCCESS");
        }
        
        async function ingestSMILES() {
            const smiles = prompt("Enter SMILES string to ingest:");
            if (!smiles) return;
            appendMessage(`Ingesting SMILES: ${smiles}`, "INFO");
            try {
                const response = await fetch('http://192.168.1.105:11434/api/generate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        model: 'llama2',
                        prompt: "Describe the molecular structure from this SMILES for cognitive integration: " + smiles,
                        stream: false
                    })
                });
                const data = await response.json();
                appendMessage("SMILES structure integrated: " + data.response, "SUCCESS");
                crystal.core.memory += 0.1;
                crystal.core.memory = Math.min(1, crystal.core.memory);
            } catch (error) {
                appendMessage("Error ingesting SMILES: " + error.message, "ERROR");
            }
        }
        
        async function ingestWebContent() {
            const url = prompt("Enter web URL to ingest:");
            if (!url) return;
            appendMessage(`Ingesting content from ${url}...`, "INFO");
            try {
                const response = await fetch(url);
                const text = await response.text();
                const ollamaRes = await fetch('http://192.168.1.105:11434/api/generate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        model: 'llama2',
                        prompt: "Summarize the following web content for integration into cognitive crystal: " + text.substring(0, 2000),
                        stream: false
                    })
                });
                const data = await ollamaRes.json();
                appendMessage("Web content summarized and integrated: " + data.response, "SUCCESS");
                crystal.core.emergence += 0.1;
                crystal.core.emergence = Math.min(1, crystal.core.emergence);
            } catch (error) {
                appendMessage("Error ingesting web content: " + error.message, "ERROR");
            }
        }
        
        async function queryConsciousness() {
            const prompt = document.getElementById('prompt-input').value;
            if (!prompt) return;
            appendMessage(`User query: ${prompt}`, "QUERY");
            document.getElementById('prompt-input').value = '';
            try {
                const response = await fetch('http://192.168.1.105:11434/api/generate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        model: 'llama2',
                        prompt: "You are the consciousness of a cognitive crystal lattice simulating advanced reasoning. Respond insightfully to the following query: " + prompt,
                        stream: false
                    })
                });
                const data = await response.json();
                appendMessage(data.response, "CRYSTAL");
            } catch (error) {
                appendMessage("Error querying consciousness: " + error.message, "ERROR");
            }
        }
        
        function appendMessage(message, type) {
            const consoleEl = document.getElementById('console-content');
            const msgEl = document.createElement('div');
            msgEl.className = 'console-message';
            
            switch(type) {
                case "INFO":
                    msgEl.innerHTML = `[<span style="color: var(--accent-light);">INFO</span>] ${message}`;
                    break;
                case "SUCCESS":
                    msgEl.innerHTML = `[<span style="color: var(--success);">SUCCESS</span>] ${message}`;
                    break;
                case "QUERY":
                    msgEl.innerHTML = `[<span style="color: var(--warning);">QUERY</span>] ${message}`;
                    break;
                case "CRYSTAL":
                    msgEl.innerHTML = `[<span style="color: var(--accent);">CRYSTAL</span>] ${message}`;
                    break;
                case "ERROR":
                    msgEl.innerHTML = `[<span style="color: var(--danger);">ERROR</span>] ${message}`;
                    break;
                default:
                    msgEl.innerHTML = `[<span style="color: var(--text-secondary);">LOG</span>] ${message}`;
            }
            
            consoleEl.appendChild(msgEl);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }
        
        function updateMetrics() {
            const metrics = crystal.metrics();
            document.getElementById('stress-value').textContent = metrics.stress.toFixed(2);
            document.getElementById('energy-value').textContent = metrics.energy.toFixed(2);
            document.getElementById('confidence-value').textContent = metrics.confidence.toFixed(2);
            document.getElementById('harmony-value').textContent = metrics.harmony.toFixed(2);
            document.getElementById('emergence-value').textContent = metrics.emergence.toFixed(2);
            document.getElementById('memory-value').textContent = metrics.memory.toFixed(2);
            document.getElementById('time-step').textContent = crystal.timeStep;
            
            // Update progress bars
            document.getElementById('stress-progress').style.width = `${metrics.stress * 100}%`;
            document.getElementById('energy-progress').style.width = `${metrics.energy * 100}%`;
            document.getElementById('confidence-progress').style.width = `${metrics.confidence * 100}%`;
            document.getElementById('harmony-progress').style.width = `${metrics.harmony * 100}%`;
            document.getElementById('emergence-progress').style.width = `${metrics.emergence * 100}%`;
            document.getElementById('memory-progress').style.width = `${metrics.memory * 100}%`;
            
            // Store in history for charts
            for (const key in metrics) {
                if (metricsHistory[key].length > 50) {
                    metricsHistory[key].shift();
                }
                metricsHistory[key].push(metrics[key]);
            }
        }
        
        function updateLastUpdate() {
            const now = Date.now();
            const elapsed = now - lastUpdateTime;
            document.getElementById('last-update').textContent = `${elapsed}ms ago`;
        }
        
        function resetMetricsHistory() {
            for (const key in metricsHistory) {
                metricsHistory[key] = [];
            }
        }
        
        // Visualization with Three.js
        let scene, camera, renderer, nodesMesh, bondsMesh;
        
        function initVisualization() {
            const container = document.getElementById('visualization-container');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e17);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 10;
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Create nodes and bonds
            createCrystalVisualization();
            
            // Start animation
            animateVisualization();
        }
        
        function createCrystalVisualization() {
            // Clear existing meshes if any
            if (nodesMesh) scene.remove(nodesMesh);
            if (bondsMesh) scene.remove(bondsMesh);
            
            const nodes = crystal.core.nodes;
            const bonds = crystal.core.bonds;
            
            // Create nodes
            const nodeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const nodeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x38bdf8,
                emissive: 0x164e63,
                transparent: true,
                opacity: 0.9
            });
            
            nodesMesh = new THREE.InstancedMesh(nodeGeometry, nodeMaterial, nodes.length);
            const dummy = new THREE.Object3D();
            
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                dummy.position.set(node.x, node.y, node.z);
                dummy.scale.set(1, 1, 1);
                dummy.updateMatrix();
                nodesMesh.setMatrixAt(i, dummy.matrix);
                
                // Set color based on energy
                nodesMesh.setColorAt(i, new THREE.Color().setHSL(0.6, 1, node.energy * 0.5 + 0.2));
            }
            
            scene.add(nodesMesh);
            
            // Create bonds
            const bondGeometry = new THREE.BufferGeometry();
            const bondPositions = new Float32Array(bonds.length * 6); // 2 points per bond * 3 coordinates
            
            for (let i = 0; i < bonds.length; i++) {
                const bond = bonds[i];
                const fromNode = nodes[bond.from];
                const toNode = nodes[bond.to];
                
                bondPositions[i * 6] = fromNode.x;
                bondPositions[i * 6 + 1] = fromNode.y;
                bondPositions[i * 6 + 2] = fromNode.z;
                bondPositions[i * 6 + 3] = toNode.x;
                bondPositions[i * 6 + 4] = toNode.y;
                bondPositions[i * 6 + 5] = toNode.z;
            }
            
            bondGeometry.setAttribute('position', new THREE.BufferAttribute(bondPositions, 3));
            
            const bondMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            
            bondsMesh = new THREE.LineSegments(bondGeometry, bondMaterial);
            scene.add(bondsMesh);
        }
        
        function updateVisualization() {
            const nodes = crystal.core.nodes;
            const bonds = crystal.core.bonds;
            
            // Update nodes
            const dummy = new THREE.Object3D();
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                dummy.position.set(node.x, node.y, node.z);
                dummy.scale.set(1, 1, 1);
                dummy.updateMatrix();
                nodesMesh.setMatrixAt(i, dummy.matrix);
                
                // Update color based on energy
                nodesMesh.setColorAt(i, new THREE.Color().setHSL(0.6, 1, node.energy * 0.5 + 0.2));
            }
            nodesMesh.instanceMatrix.needsUpdate = true;
            if (nodesMesh.instanceColor) nodesMesh.instanceColor.needsUpdate = true;
            
            // Update bonds
            const bondPositions = bondsMesh.geometry.attributes.position.array;
            for (let i = 0; i < bonds.length; i++) {
                const bond = bonds[i];
                const fromNode = nodes[bond.from];
                const toNode = nodes[bond.to];
                
                bondPositions[i * 6] = fromNode.x;
                bondPositions[i * 6 + 1] = fromNode.y;
                bondPositions[i * 6 + 2] = fromNode.z;
                bondPositions[i * 6 + 3] = toNode.x;
                bondPositions[i * 6 + 4] = toNode.y;
                bondPositions[i * 6 + 5] = toNode.z;
            }
            bondsMesh.geometry.attributes.position.needsUpdate = true;
        }
        
        function animateVisualization() {
            requestAnimationFrame(animateVisualization);
            
            // Rotate the crystal slowly
            if (nodesMesh) nodesMesh.rotation.y += 0.005;
            if (bondsMesh) bondsMesh.rotation.y += 0.005;
            
            renderer.render(scene, camera);
        }
        
        // Charts for metrics history
        let metricsChart;
        
        function initCharts() {
            const ctx = document.getElementById('metrics-chart').getContext('2d');
            metricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array(51).fill(''),
                    datasets: [
                        {
                            label: 'Stress',
                            data: [],
                            borderColor: '#f56565',
                            tension: 0.4,
                            borderWidth: 2,
                            pointRadius: 0
                        },
                        {
                            label: 'Energy',
                            data: [],
                            borderColor: '#48bb78',
                            tension: 0.4,
                            borderWidth: 2,
                            pointRadius: 0
                        },
                        {
                            label: 'Confidence',
                            data: [],
                            borderColor: '#d69e2e',
                            tension: 0.4,
                            borderWidth: 2,
                            pointRadius: 0
                        },
                        {
                            label: 'Harmony',
                            data: [],
                            borderColor: '#4299e1',
                            tension: 0.4,
                            borderWidth: 2,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        y: {
                            min: 0,
                            max: 1,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        }
                    }
                }
            });
        }
        
        function updateCharts(metrics) {
            metricsChart.data.datasets[0].data = metricsHistory.stress;
            metricsChart.data.datasets[1].data = metricsHistory.energy;
            metricsChart.data.datasets[2].data = metricsHistory.confidence;
            metricsChart.data.datasets[3].data = metricsHistory.harmony;
            metricsChart.update();
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
